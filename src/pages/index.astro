---
import { getCollection } from 'astro:content';
import Layout from '../layouts/Layout.astro';

const allPosts = await getCollection('blog');

// フィーチャード記事のIDを指定（順番通りに表示）
const featuredPostIds = ['049', '050','047', '048','007']; 

// フィーチャード記事を指定された順番で取得
const posts = featuredPostIds.map(id => 
  allPosts.find(post => post.data.id === id)
).filter(Boolean); // undefinedを除外

// Gallery用の折り紙作品を取得
let galleryItems: Array<{
  id: string;
  title: string;
  author: string;
  publisher?: string;
  description: string;
  imagePath: string;
  tags: string[];
}> = [];

// 折り紙作品がある投稿のみを対象とする
for (const post of allPosts) {
  if (post.data.images?.origami && !post.data.title.includes('を折らない')) {
    const origamiImages = Array.isArray(post.data.images.origami) 
      ? post.data.images.origami 
      : [post.data.images.origami];
    
    if (origamiImages.length > 0) {
      galleryItems.push({
        id: post.data.id || post.slug,
        title: post.data.title,
        author: post.data.author,
        publisher: post.data.publisher,
        description: post.data.description,
        imagePath: origamiImages[0], // 最初の折り紙画像を使用
        tags: post.data.tags || []
      });
    }
  }
}

// ID順でソート（新しい順）
galleryItems.sort((a, b) => parseInt(b.id) - parseInt(a.id));
---

<Layout title="Paper After Word" currentPage="top">

  <div class="page-header">
    <h1>Paper After Word</h1>
    <p>本を読んで、読んだ本を折り紙にする。</p>
  </div>

    <main class="content">
        <figure class="camera-photo-container">
          <canvas id="origami-canvas" class="camera-photo"></canvas>
          <figcaption class="photo-caption">
            « Fais ce que voudras.» 汝の欲するところを為せ
            <span class="quote-author">— フランソワ・ラブレー</span>
          </figcaption>
        </figure>
      <div class="intro">
        <p>本というものは、読み終えた後、ただ棚に並べておくばかりでは、どうにもその余情が空に散ってしまうように思われる。<br />
          折り紙が好きで、せっかく紙がそこにあるのなら...
        </p>
        <p>そこに積み重なった紙の山を、静かに別の姿へと折り変えてみたくなる。文字はすでに胸の裡に沈み込み、その用を終えた紙は、今や形そのもののために在る。</p>
        <p>ここでは、読み終えた本の紙を折り紙にし、本の感想と合わせてその記録を残す。<br />
          意味があるかどうかはわからないが、手を動かしていると、そのこと自体が少しおもしろい。</p>
        
          <a href="/story" class="more-posts-link">
            あらすじを読む
          </a>
      </div>


      <h2 id="blog" class="section-title">Works and Reviews</h2>    
      <p>作品一覧</p>  
      <div class="posts">
        {posts.map((post) => (
          <article class="post">
            <div class="post-content">
              <h3><a href={`/blog/${post.data.id || post.slug}`}>{post.data.title}</a></h3>
              <div class="meta">
                <span class="author-info">
                  {post.data.author}
                  {post.data.translator && <span>（訳：{post.data.translator}）</span>}
                  {post.data.publisher && <span class="publisher"> / {post.data.publisher}</span>}
                </span>
              </div>
              <p><a href={`/blog/${post.data.id || post.slug}`}>{post.data.description}</a></p>
            </div>
            {post.data.images?.bookCover && (
              <div class="post-images">
                <a href={`/blog/${post.data.id || post.slug}`}>
                  <img src={post.data.images.bookCover} alt={post.data.title} loading="lazy" decoding="async" />
                </a>
              </div>
            )}
          </article>
        ))}
      </div>
      
      <!-- 他の作品を見るリンク -->
      {allPosts.length > 5 && (
        <div class="more-posts">
          <a href="/blog" class="more-posts-link">
            他の作品を見る
          </a>
        </div>
      )}
      
      <section id="gallery" class="section">
      <h2 id="blog" class="section-title">Gallery</h2>    
      <p>クリックして作品を見る</p>  
        {galleryItems.length > 0 ? (
          <div class="gallery-container">
            <div class="gallery-grid">
              {galleryItems.map((item) => (
                <div class="gallery-item">
                  <a href={`/blog/${item.id}`} class="gallery-link">
                    <img src={item.imagePath} alt={`${item.title}の折り紙作品`} class="gallery-image" />
                  </a>
                </div>
              ))}
            </div>
          </div>
        ) : (
          <p class="section-text">折り紙作品のギャラリーは準備中です。</p>
        )}
      </section>
      
      <!-- <section id="shop" class="section">
        <h2>Shop</h2>
        <p class="section-text">オンラインショップは準備中です。</p>
        <div class="shop-image">
          <img src="/assets/paperafterword.jpg" alt="Paper After Word" />
        </div>
      </section> -->
      
      <section id="sns" class="section">
        <h2 class="section-title">SNS</h2>
        <div class="sns-links">
          <a href="https://twitter.com/paperafterword" target="_blank" rel="noopener noreferrer" class="sns-link">
            <span>𝕏</span>
          </a>
          <a href="https://jp.pinterest.com/paperafterword/" target="_blank" rel="noopener noreferrer" class="sns-link">
            <img src="/assets/pinterest.png" alt="Pinterest">
          </a>
        </div>
      </section>
</Layout>

<script>
  const img = new Image();
  img.src = "/assets/zatto.png";
  img.onload = () => {
    const origW = img.width;
    const origH = img.height;

    const canvas = document.getElementById("origami-canvas");
    const ctx = canvas.getContext("2d");
    
    // 高品質な描画設定
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    function ease(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }

    function setupAnimation(W, H) {
      // === 横折り（第1段階） ===
      function drawHorizontal1(progress) {
        const t = ease(progress);
        const angle = t * Math.PI;
        const cos = Math.cos(angle);
        const flapW = Math.abs(cos) * (W / 2);

        ctx.clearRect(0, 0, W, H);

        // 左半分（画像）
        ctx.drawImage(img, 0, 0, origW / 2, origH, 0, 0, W / 2, H);

        // 右半分（折れる）
        if (cos >= 0) {
          ctx.drawImage(img, origW / 2, 0, origW / 2, origH, W / 2, 0, flapW, H);
        } else {
          ctx.fillStyle = "#f5f5dc";
          ctx.fillRect(W / 2 - flapW, 0, flapW, H);
        }

        // 折り目の線（1回目の横折り）
        if (progress > 0.05 && progress < 0.95) {
          ctx.strokeStyle = "#ccc";
          ctx.lineWidth = 0.5;
          ctx.beginPath();
          ctx.moveTo(W / 2, 0);
          ctx.lineTo(W / 2, H);
          ctx.stroke();
        }

        // 影
        if (angle > Math.PI / 2 && angle < Math.PI) {
          const edgeX = W / 2 - flapW;
          const ratio = (angle - Math.PI / 2) / (Math.PI / 2);

          // 濃さは後半で急に暗くなる
          let alpha = 0.5 * Math.pow(ratio, 1.5);
          if (angle >= Math.PI - 0.01) alpha = 0;

          // 影の長さは最初は一気に伸び、後半は緩やか
          const shadowLen = (W / 2) * Math.sin(ratio * Math.PI / 2);

          const grad = ctx.createLinearGradient(edgeX, 0, edgeX - shadowLen, 0);
          grad.addColorStop(0, `rgba(0,0,0,${alpha})`);
          grad.addColorStop(0.3, `rgba(0,0,0,${alpha * 0.6})`);
          grad.addColorStop(1, "rgba(0,0,0,0)");

          ctx.fillStyle = grad;
          ctx.fillRect(edgeX - shadowLen, 0, shadowLen, H);
        }
      }

      // === 縦折り（第2段階：白紙） ===
      function drawVertical(progress) {
        const t = ease(progress);
        const angle = t * Math.PI;
        const cos = Math.cos(angle);
        const flapH = Math.abs(cos) * (H / 2);

        ctx.clearRect(0, 0, W / 2, H);

        ctx.fillStyle = "#f5f5dc";
        ctx.fillRect(0, 0, W / 2, H / 2);

        ctx.fillStyle = "#f5f5dc";
        if (cos >= 0) {
          ctx.fillRect(0, H / 2, W / 2, flapH);
        } else {
          ctx.fillRect(0, H / 2 - flapH, W / 2, flapH);
        }

        // 折り目の線（2回目の縦折り）
        if (progress > 0.05 && progress < 0.95) {
          ctx.strokeStyle = "#ccc";
          ctx.lineWidth = 0.5;
          ctx.beginPath();
          ctx.moveTo(0, H / 2);
          ctx.lineTo(W / 2, H / 2);
          ctx.stroke();
        }

        if (angle > Math.PI / 2 && angle < Math.PI) {
          const edgeY = H / 2 - flapH;
          const ratio = (angle - Math.PI / 2) / (Math.PI / 2);
          let alpha = 0.4 * ratio;
          if (angle >= Math.PI - 0.01) alpha = 0;
          const shadowLen = (H / 2) * ratio;

          const grad = ctx.createLinearGradient(0, edgeY, 0, edgeY - shadowLen);
          grad.addColorStop(0, `rgba(0,0,0,${alpha})`);
          grad.addColorStop(1, "rgba(0,0,0,0)");

          ctx.fillStyle = grad;
          ctx.fillRect(0, edgeY - shadowLen, W / 2, shadowLen);
        }
      }

        // === 横折り（第3段階：白紙） ===
        function drawHorizontal2(progress) {
          const t = ease(progress);
          const angle = t * Math.PI;
          const cos = Math.cos(angle);
          const flapW = Math.abs(cos) * (W / 4);

          ctx.clearRect(0, 0, W / 2, H / 2);

          ctx.fillStyle = "#f5f5dc";
          ctx.fillRect(0, 0, W / 4, H / 2);

          ctx.fillStyle = "#f5f5dc";
          if (cos >= 0) {
            ctx.fillRect(W / 4, 0, flapW, H / 2);
          } else {
            ctx.fillRect(W / 4 - flapW, 0, flapW, H / 2);
          }

          // 折り目の線（3回目の横折り）
          if (progress > 0.05 && progress < 0.95) {
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(W / 4, 0);
            ctx.lineTo(W / 4, H / 2);
            ctx.stroke();
          }

          if (angle > Math.PI / 2 && angle < Math.PI) {
            const edgeX = W / 4 - flapW;
            const ratio = (angle - Math.PI / 2) / (Math.PI / 2);
            let alpha = 0.4 * ratio;
            if (angle >= Math.PI - 0.01) alpha = 0;
            const shadowLen = (W / 4) * ratio;

            const grad = ctx.createLinearGradient(edgeX, 0, edgeX - shadowLen, 0);
            grad.addColorStop(0, `rgba(0,0,0,${alpha})`);
            grad.addColorStop(1, "rgba(0,0,0,0)");

            ctx.fillStyle = grad;
            ctx.fillRect(edgeX - shadowLen, 0, shadowLen, H / 2);
          }
        }


      // === クリック制御 ===
      let isAnimating = false;
      let isCompleted = false; // アニメーション完了フラグ
      let currentStage = 0;
      let animationProgress = 0;
      let animationStartTime = 0;
      const animationDuration = 1000; // 1秒で完了

      function animate() {
        if (!isAnimating) return;

        const currentTime = Date.now();
        const elapsed = currentTime - animationStartTime;
        const progress = Math.min(1, elapsed / animationDuration);

        if (progress < 1) {
          // アニメーション継続
          if (currentStage === 0) {
            drawHorizontal1(progress);
          } else if (currentStage === 1) {
            drawVertical(progress);
          } else if (currentStage === 2) {
            drawHorizontal2(progress);
          }
          requestAnimationFrame(animate);
        } else {
          // 現在のステージ完了
          if (currentStage === 0) {
            currentStage = 1;
            animationStartTime = currentTime;
            requestAnimationFrame(animate);
          } else if (currentStage === 1) {
            currentStage = 2;
            animationStartTime = currentTime;
            requestAnimationFrame(animate);
          } else {
            // 全アニメーション完了
            isAnimating = false;
            isCompleted = true; // 完了フラグを立てる
            currentStage = 0;
          }
        }
      }

      function startAnimation() {
        if (isAnimating || isCompleted) return; // 完了済みの場合は実行しない
        
        isAnimating = true;
        currentStage = 0;
        animationStartTime = Date.now();
        animate();
      }

      // クリックイベントを追加
      canvas.addEventListener("click", startAnimation);
      
      // 初回描画
      drawHorizontal1(0);
    }

    function resize() {
      // CSSの設定に合わせたサイズ計算
      const isMobile = window.innerWidth <= 768;
      const maxWidth = isMobile ? window.innerWidth : Math.min(500, window.innerWidth * 0.9);
      const targetHeight = isMobile ? 250 : 375;
      
      // アスペクト比を保持しながらサイズを計算
      const aspectRatio = origW / origH;
      let W, H;
      
      if (maxWidth / targetHeight > aspectRatio) {
        // 高さ基準
        H = targetHeight;
        W = Math.round(H * aspectRatio);
      } else {
        // 幅基準
        W = maxWidth;
        H = Math.round(W / aspectRatio);
      }
      
      // デバイスピクセル比を考慮して高解像度で描画（サイズは変更しない）
      const dpr = window.devicePixelRatio || 1;
      canvas.width = W * dpr;
      canvas.height = H * dpr;
      
      // コンテキストをスケールして高解像度対応
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      
      setupAnimation(W, H);
    }

    resize();
    window.addEventListener("resize", resize);
  };
</script>